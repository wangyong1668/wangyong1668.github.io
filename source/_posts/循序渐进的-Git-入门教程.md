---
title: 循序渐进的 Git 入门教程
date: 2017-07-04 21:18:54
categories:
- 运维
tags:
- Git
- 教程
---

# Git 由来

## 为什么需要版本控制
举一个简单的例子，如果你用Microsoft Word写过长篇大论，那你一定有这样的经历： 

想删除一个段落，又怕将来想恢复找不回来怎么办？有办法，先把当前文件“另存为……”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件，这样一直改下去，最后你的Word文档变成了这样： 

![为什么需要版本控制](https://static.oschina.net/uploads/img/201707/04093532_Lqiw.jpg "为什么需要版本控制")

过了一周，你想找回被删除的文字，但是已经记不清删除前保存在哪个文件里了，只好一个一个文件去找，真麻烦。

看着一堆乱七八糟的文件，想保留最新的一个，然后把其他的删掉，又怕哪天会用上，还不敢删，真郁闷。

更要命的是，有些部分需要你的其他同事帮助填写，于是你把文件Copy到U盘里给她（也可能通过Email发送一份给她），然后，你继续修改Word文件。一天后，同事再把Word文件传给你，此时，你必须想想，发给她之后到你收到她的文件期间，你作了哪些改动，得把你的改动和她的部分合并，真困难。

于是你想，如果有一个软件，**不但能自动帮我记录每次文件的改动，还可以让同事协作编辑**，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以，岂不是很方便？

这个软件用起来就应该像这个样子，能记录每次文件的改动：

版本 | 用户 | 说明 | 日期
---|---|---|---|
1 | 张三 | 删除了第一段简介 | 2015/4/18 13:25
2 | 张三 | 增加了第二，三，四，五段的内容 | 2015/4/19 12:30
3 | 李四 | 修改了第三段合同金额数据 | 2015/4/20 09:09
4 | 王五 | 修改了第四段关于后续维护的条款 | 2015/5/01 11:22

> 对每一次修改进行记录，每一次修改都是一个新的版本，这就是版本控制。

## 集中式版本控制与分布式版本控制的区别

> 目前市场上有两种版本控制：集中式和分布式。

先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。

![集中式版本控制图解](https://static.oschina.net/uploads/img/201707/04094224_8qul.jpg "集中式版本控制图解")

**集中式版本控制系统最大的毛病就是必须联网才能工作**，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。

那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。

和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。

在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。

![分布式版本控制图解](https://static.oschina.net/uploads/img/201707/04094332_lgzF.jpg "分布式版本控制图解")

## 牛是怎么定义的

- **Git 的诞生** 

很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。

Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？

事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！

你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。

不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。

安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。

Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：

Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。

Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。

历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。

- **目前市场上的版本控制**

CVS作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于CVS自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的SVN修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统。

除了免费的外，还有收费的集中式版本控制系统，比如IBM的ClearCase（以前是Rational公司的，被IBM收购了），特点是安装比Windows还大，运行比蜗牛还慢，能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗，或者人傻钱多。

微软自己也有一个集中式版本控制系统叫VSS，集成在Visual Studio中。由于其反人类的设计，连微软自己都不好意思用了。

分布式版本控制系统除了Git以及促使Git诞生的BitKeeper外，还有类似Git的Mercurial和Bazaar等。这些分布式版本控制系统各有特点，但最快、最简单也最流行的依然是Git！

# Git 安装

> 由于作者使用的 window 系统，这里也就只介绍 window 下的 Git 安装。

## 下载安装包

上一节介绍到 Git 是由 Linus 花了一个月时间创造的，最初只在 Linux 系统上运行。

由于 window 的用户很多，有大牛写了 window 版本的 Git，叫做：msysgit。（不用担心与 Git 会不会不一样，答案是一样的）

[Git 安装程序下载](http://pan.baidu.com/s/1gfingvL)

过程中下一步下一步即可。

## 校验是否安装成功

- 安装成功后，在 **[开始]** -> **[所有程序]** 中可以看到 **[Git Bash]**，这是 Git 自带的命令行工具。

- 当然我们也可以使用 window 系统自带的命令行工具 **[Dos]**，打开 Dos 窗口后输入 git 回车会看到相关信息。

- 后面的章节我们将会循序渐进的讲解 Git 的使用，需要使用到命令行工具，上面介绍的两种命令行工具根据自己爱好选择一个即可。

# 版本库

## 什么是版本库

举例说明：

在 d 盘下有个 git-demo 目录（路径：d:\git-demo）。

该目录下有个 .git 目录，这个 .git 目录就叫做版本库，负责管理 .git 目录所在目录 git-demo 里的文件。


![什么是版本库](https://static.oschina.net/uploads/img/201707/04180359_iJIH.png "什么是版本库")

### 版本库的作用

版本库可以认为是一个仓库，仓库里用来放置工作空间的每一个版本信息。

git-demo 目录（除了 .git 目录以外）可以认为是工作空间。

最佳实践是每一次进入工作空间，不管进行多长时间的工作，修改或是删除了哪些文件，在你准备休息的时候都应该将当前工作空间放到版本库中做一次存储，也就是创建一个当前状态的版本。

这个过程就好比玩网络游戏，在进入 Boss 之前对游戏设置断点存储，这样如果 Boss 打失败了，可以选择断点存储回到进入 Boss 前的那个状态。

这里的断点存储就相当于将工作空间放到版本库中进行一次断点存储。如果之后对工作空间的修改并不满意，可以从版本库中找到之前存储的那个版本，替换当前工作空间即可回到上一个版本。

具体如何回滚后面一一介绍。

### 创建版本库

- 新建一个空目录：d:\git-demo

- 打开 dos 窗口，定位到该目录下:

    ```
    $ cd d:\git-demo
    ```

- 使用 git init 指令将当前目录变成 Git 的版本库

    ```
    $ git init
    ```

- 查看是否创建成功

创建成功后，在当前目录下应该会出现一个 .git 的文件夹。

如果没有看见，说明你的计算机默认将这个文件夹隐藏起来了，通过以下操作可以显示出来看到：

![显示隐藏的文件夹](https://static.oschina.net/uploads/img/201707/04163934_lX9W.png "显示隐藏的文件夹")

> **注意：该文件夹看看就行，里面的东西一个也别动，否则你的版本库有可能会崩溃。**

## 版本库的设计原理

> 上一节介绍了版本库的概念，这一节介绍工作空间与版本库中是如何进行交互的。通过揣摩作者是如何设计 Git 的，来确定我们学习 Git 究竟要学习哪些东东。

### 将文件添加到版本库

> 假设你已经按照 2.1 节创建了版本库，管理的目录为 d:\git-demo。

> 接下来先跟着操作一遍，有疑惑先放着，下面会根据这个例子来介绍具体过程是如何操作的。

- 在 git-demo 目录下新建文件 readme.txt

    内容如下：（d:\git-demo\readme.txt）

    ```
    create a readme.txt file.
    ```

- 打开 dos 窗口切换到 git-demo 目录下

    ```
    $ cd d:\git-demo
    ```

- 输入 git status 查看状态

    状态值：Untracked files，表示这是一个新增的文件。    

    ![status1](https://static.oschina.net/uploads/img/201707/04231557_0S64.png "status1")


- 将 readme.txt 添加到版本库

    ```
    $ git add readme.txt
    ```

- 输入 git status 查看状态

    状态值：Changes to be commited，表示版本库已经知道了工作空间被修改了。

    ![status2](https://static.oschina.net/uploads/img/201707/04231655_Fi7S.png "status2")

- 将 readme.txt 提交到版本库

    ```
    $ git commit -m "add a readme.txt file"
    ```
- 输入 git status 查看状态

    状态值：nothing to commit，表示工作空间的修改已经作为一个版本放到了版本库。

    ![status3](https://static.oschina.net/uploads/img/201707/04231840_0SoG.png "status3")

- 修改 readme.txt 文件，内容如下：（d:\git-demo\readme.txt）

    ```
    create a readme.txt file.
    This is the second revision of the document.
    ```

- 输入 git status 查看状态

    状态值：Changes not staged for commit，表示版本库知道文件被修改了，只是还没有提交。

    ![status4](https://static.oschina.net/uploads/img/201707/04232113_51G1.png "status4")


### git 设计原理

> 通过上面的例子，我们有理由推测 git 在添加/修改文件到版本库中是这样操作的：

- 首先通过 git add 指令将工作区中的内容添加到暂存区；
- 再通过 git commit 指令将暂存区中内容添加到版本库中。

![版本库设计原理图](https://static.oschina.net/uploads/img/201707/04232417_VJG2.png "版本库设计原理图")

- 相关概念说明：
    - 工作区：git-demo 目录（除了 .git 目录以外）可以认为是工作空间
    - 版本库：.git 目录可以认为是版本库，其中版本库中包含两个东东
        - stage：叫做暂存区
        - master：分支，也就是真正意义上存放版本的仓库了
  
> 看到上图我们不禁会想：**为什么 git 的作者在设计时不直接将工作区中修改的文件直接添加到master版本库中，而要在中间再加一层 stage 暂存区呢？**

dk 想了又想，再次做出推测：

> 抽象成思维导图就是像下面这样的：
  
![git 是如何设计的](https://static.oschina.net/uploads/img/201707/04234146_cGPf.png "git 是如何设计的")

> **这里纠正一个错误，将 master 版本库替换成 master 分支仓库更合适。**

![寄快递对比图](https://static.oschina.net/uploads/img/201707/04235132_GFGT.png "寄快递对比图")

对比上面两张思维导图，可得出如下结论：

- 如果小明寄快递到代收点，代收点马上就将快递送到快递公司；小红紧接着又将快递寄到代收点，代收点再次送到快递工资；与代收点在一天内收到小明、小红、小花的快递，在晚上的时候一并将快递送到快递公司。哪种看起来更好不言而喻。

- 版本库，作为一个仓库保存着不同版本的信息，如果每一次小修改都打一条版本信息放到版本库，那无疑会大大增加版本库的容量。最佳实践时将一定时间内的所有修改作为一条版本放到版本库中最节约资源。

- 如果小明寄快递到代收点，后来发现东西记错了，想要取回来，直接去代收点拿回来就可以了。如果没有代收点，小明的快递直接寄到快递公司，被快递公司放到了大货车上就不是那么容易拿回来了。放到版本库中的暂存区也就是方便你撤销你的修改。

> **现在再回过头来看看 1 中示例代码，是不是对整个流程知根知底了，对工作区，暂存区和版本库的概念也大致熟悉了。如果不熟悉，请将本节重新阅读一遍。**

### 暂存区管理的是修改，不是文件

老的版本控制系统比如 svn，管理的是文件，也就是你每一次将本地代码提交到仓库时，实际上提交的都是文件，而文件如果一多，就会导致同步速度很慢。（使用过 svn 的应该有感受）

Git 的作者考虑到这一点，舍弃了管理文件的思想，使用管理修改的新新思想，这也就是为什么使用 Git 速度很快的原因。

举例说明：

- 在 git-demo 目录下新建 test.txt 文件

    内容如下：（d:\git-demo\test.txt）
    
    ```
    this is a test.txt file.
    ```

- 将 test.txt 文件添加到暂存区

    ```
    $ git add test.txt
    ```
- 修改 test.txt 文件

    内容如下：
    
    ```
    this is a test.txt file.
    This is the second revision of the document.
    ```
- 将 test.txt 文件提交到分支仓库

    ```
    $ git commit -m "add test.txt"
    ```

- 使用 git status 查看状态

    ```
    $ git status
    ```
    ![管理的是修改](https://static.oschina.net/uploads/img/201707/05103348_MiZz.png "管理的是修改")

**我们明明 commit 了 test.txt 文件，为什么还显示有东西要提交呢？**

我们来分析一下这个过程：

![管理的是修改](https://static.oschina.net/uploads/img/201707/05104549_coQf.png "管理的是修改")

- 在示例代码中，第一次新增 test.txt 文件后使用 git add 把它放到了暂存区中；

- 第二次修改 test.txt 文件后并没有添加暂存区而直接使用 git commit 操作将暂存区中内容提交到分支仓库中。

- 因此，使用 git status 时可以看到仍然有一个修改，提示值："Changes not staged for commit"也可以看出有个修改没有放到暂存区中，stated 就是暂存区的意思。

- 如果管理的是文件，在使用 git commit 时应该就将 test.txt 文件直接添加到版本库中。使用管理修改而不管理文件的目的是让这个过程变得更快，因为修改可以是一段描述性的字符串即可。

### Git 我们主要学些什么

经过上面的学习，我们知道使用版本控制就是将本地工作区的代码在分支仓库中进行备份，而我们关心的操作就是如何从本地到暂存区到分支仓库这一条流水线的正常工作。

![git 要学什么](https://static.oschina.net/uploads/img/201707/05110228_LB81.png "git 要学什么")

本节我们已经学习过在这条流水线上新增操作了，在接下来的章节将学习撤销操作与删除操作。

当然，上述三种操作可以看成是将文件塞到分支仓库，那么从分支仓库中将备份取出来也至关重要，因此，我们还要学习如何回滚版本库中指定备份。

### 总结

- 本节介绍了 Git 的设计原理
    
    主要要掌握工作区、暂存区与分支版本库的概念。

- 根据设计原理确定接下来的学习路线

    - 将本地代码备份到分支仓库流水线：工作区 - 暂存区 - 分支仓库；
    
    - 已经介绍过新增操作，通过 git add 添加到暂存区，通过 git commit 提交到分支仓库；
    
    - 接下来学习撤销操作和删除操作。

- 介绍了暂存区时管理修改而不是管理文件

    这一点没看懂的拉上去再看一遍    

- 学习到了三个指令

    - **git add <filename>**
    
        提交工作区中文件到暂存区
    
    - **git commit -m <descrption>**
    
        将暂存区中所有修改提交到分支仓库中；
        
        -m 后面紧跟着的是对当前版本的一段描述话语，方便以后再分支仓库中快速找到某个版本；
        
        注意：这里要用双引号，不能用单引号。
        
    - **git status**
    
        查看文件/目录在 git-demo 目录下的状态，好比收快递时查的物流信息一样。
        
        ![文件在版本库中的位置](https://static.oschina.net/uploads/img/201707/05082757_COnQ.png "文件在版本库中的位置")

## 分支仓库相关操作

> 在2.2 节中我们根据一个示例分析了版本库的设计原理，并确定了学习 Git 的路线。这一节就版本库相关操作进行详细叙述。

![版本库设计原理图](https://static.oschina.net/uploads/img/201707/04232417_VJG2.png "版本库设计原理图")

![git 是如何设计的](https://static.oschina.net/uploads/img/201707/04234146_cGPf.png "git 是如何设计的")

### 复习上一节内容

首先复习下上一节的内容，修改 readme.txt 然后提交到版本库中。

- 修改 d:\git-demo 目录下的 readme.txt

    内容如下：

    ```
    create a readme.txt file.
    This is the second revision of the document.
    today is a sunny day.
    ```

- 使用 git add 指令添加到暂存区中

    ```
    $ git add readme.txt
    ```
- 使用 git commit 指令将这一条版本信息添加到分支仓库中

    别忘了写版本描述信息，也就是 -m 后面紧跟着的字符串。

    ```
    $ git commit -m "today is a sunny day"
    ```
### 查看版本日志信息


- 前面说过分支仓库是存放版本信息的，可以使用 **git log** 指令查看某个分支仓库中的版本信息。

    ```
    $ git log
    ```

    ![git log](https://static.oschina.net/uploads/img/201707/05085757_nV7U.png "git log")

    可以看到当前分支仓库中有两个版本，通过版本描述信息可以看到每个版本大概做了哪些修改。
    
    上图中每条版本信息会包含四项内容：
    
    - commit：每创建一条版本信息时，都会用 SHA1 生成一个很大的数字，并用十六进制进行表示，目的是根据这个 commit id 可以找到对应的版本信息，不会重复。
    
    - Author：提交这条版本信息的人是谁，适用于团队开发时，记录每个版本是谁提交的，这样出了问题也好找对应的负责人解决问题。
    
    - Date：这个就是提交到分支仓库的时间了。
    
    - 再下面用红框框起来的东东叫做版本描述信息，如果没有它，你看到的只是一大串数字，压根不知道这条版本到底做了哪些修改。

- 感觉日志信息输出太多，可以使用 **git log --pretty=oneline** 在一行显示日志

    ```
    $ git log --pretty=oneline
    ```

    ![git log pretty=oneline](https://static.oschina.net/uploads/img/201707/05091442_QESn.png "git log pretty=oneline")
    
### 回滚到指定版本

上面查看了分支仓库中有两个版本，现在在体验下版本控制工具的神奇之处，让我们将工作区回滚到第一个版本，也就是 "add a readme.txt file" 的那个版本。

- 在回滚之前，先查看下当前 readme.txt 的内容：

    ```
    create a readme.txt file.
    This is the second revision of the document.
    today is a sunny day.
    ```

- 使用 **git reset --hard <commit id>** 指令进行版本回滚

    ```
    $ git reset --hard b4977875
    ```
    
    ![版本回滚](https://static.oschina.net/uploads/img/201707/05092615_v1ON.png "版本回滚")

    说明：--hard 后面跟着的字符串是要回滚到的那条版本信息对应的 commit id，当然不需要全部写，只需要截取前面7-8位唯一标识即可。

- 此时再打开 readme.txt 文件，会看到内容如下：

    ```
    create a readme.txt file.
    ```

- 但是，当我们再次查看历史记录时会发现分支仓库中只有一条版本信息了：

    ![回滚版本后查询日志](https://static.oschina.net/uploads/img/201707/05093114_XdwS.png "回滚版本后查询日志")

- 这就很不爽了，刚才我只是测试版本库的回滚功能，并不想丢弃 "today is a sunny day" 那条版本信息。难道回不去？答案当然是不！

    使用 git reflog 指令查看刚才所有操作日志
    
    ![查看刚才所有操作日志](https://static.oschina.net/uploads/img/201707/05093453_yfra.png "查看刚才所有操作日志")

- 重复 git reset --hard <commit id> 就可以回到 "today ...." 的那个版本了。这里就不再赘述，自行练习即可。

### git log 与 git reflog 的区别

通过上面的操作，我们看到 git log 和 git relog 好像都可以查询日志记录，那它们之间又什么区别呢？

- git log：只查询文件修改/新增/删除等与文件有关的日志记录；
- git reflog：不仅记录与文件有关的记录，还会记录对分支仓库的回滚记录。

![log 与 reflog 的区别](https://static.oschina.net/uploads/img/201707/05094139_TNbl.png "log 与 reflog 的区别")

### 总结
本节介绍了版本库的基本操作，主要为查看版本库中版本信息，切换到任何你想切换的版本。

- **git log** ：查看版本库版本更新日志，显示详细信息
- **git log --pretty=oneline**：查看版本库版本更新日志，显示主要信息
- **git reset --hard <commit id>**：回滚到指定版本
- **git reflog**：查看版本信息和回滚信息

## 撤销操作

### 场景一：在工作区乱七八糟改一通想要还原，并没有添加到暂存区。

在写代码的时候，如果没有提前将整个逻辑理清楚就开始修改之前的代码，那么大多数情况是到最后自己都不知道写的啥，这时候就会想要回到自己修改之前的那个版本。

前提是一直在工作区进行修改，并没有添加到暂存区。

解决思路：

- 在修改之前在分支仓库中进行一次备份

    使用 git status 查询状态，如果本地工作区与分支仓库不同步（本地工作区有文件修改了咩有提交）,参照 2.2 节先同步；
    
- 修改之后，不满意，只需将之前在分支仓库中的（该文件/整个目录）备份取出来替换工作区内容即可。

![工作区撤销](https://static.oschina.net/uploads/img/201707/05123339_EzG3.png "工作区撤销")

具体操作：

```
$ git checkout -- <filename>
```

说明：由于这里没有添加到暂存区，所以该指令表示将分支仓库中的（该文件/整个目录）备份取出来替换工作区的内容。

### 场景二：将工作区修改过内容添加到暂存区后又对工作区文件进行修改想要还原

场景二的标题有点长，拆分一下做了以下几件事情：

- 对工作区内容 readme.txt 进行修改 —— 状态1；
 
- 将修改后的文件 readme.txt 添加到暂存区,此时没有提交到分支仓库 —— 状态2；

- 再次对工作区内容 readme.txt 进行修改 —— 状态3。

![撤回场景2](https://static.oschina.net/uploads/img/201707/05140452_tOS9.png "撤回场景2")

现在想要将状态3撤回到原始状态，我们分析下如何做：

- 状态3 撤回到状态2

    - 状态2 对 readme.txt 进行修改并添加到暂存区

    - 状态3 对 readme.txt 进行修改并添加到暂存区，再次修改 readme.txt
    
    ```
    // $ git checkout -- <filename>
    $ git checkout -- readme.txt
    ```

- 状态2 撤回到状态1

    - 状态1 对 readme.txt 进行修改
    
    - 状态2 对 readme.txt 进行修改并添加到暂存区
    
    ```
    // $ git reset HEAD <filename>
    $ git reset HEAD readme.txt
    ```
    
- 状态1 撤回到 原始状态

    - 原始状态 readme.txt 与分支仓库的备份一毛一样
    
    - 状态1 对 readme.txt 进行修改
    
    其实到这里已经回到了场景1遇到的情况：只在工作区进行修改，并没有添加到暂存区，如何还原？
    
    ```
    // $ git checkout -- <filename>
    $ git checkout -- readme.txt 
    ```

作者这里已经尽可能的把情况说的简单点，无奈言语显得有点脆弱，还需要自己实践敲一篇试验一下，记住，每次撤回到上一个状态时使用 git status 查看下当前状态。

### 场景三：在工作区修改了文件，不仅添加到了暂存区，还提交到了分支仓库中，想要还原怎么办

这种情形反而更简单，提交到分支库，将相当于对当前状态做了一个备份放到分支仓库中取代了最新的备份，我们只需要将分支仓库中上一个备份取出来替代工作区内容即可。

详细内容在 2.4 节已经讲解过，这里简要略过。

- 查看分支仓库版本备份信息

    ```
    $ git log --pretty=oneline
    ```

    ![撤回提交1](https://static.oschina.net/uploads/img/201707/05142303_BsKY.png "撤回提交1")

- 使用 git reset 指令回到上一个版本

    ```
    $ git reset --hard 7e46747    
    ```

    ![撤回提交2](https://static.oschina.net/uploads/img/201707/05142504_A1sF.png "撤回提交2")

### 结论

又到了总结时间，本节以实际场景触发，考虑到所有需要撤回的场景，需要多加练习。

- 场景1：修改了工作区内容没有添加到暂存区撤回操作；

- 场景2：修改了工作区添加到暂存区又修改了该文件撤回操作（详细介绍三步自操作）；

- 场景3：修改了工作区内容添加到暂存区又提交到分支仓库后撤回操作。

## 删除操作

> 本节假设你已经创建了版本库，路径为 d:\git-demo。如未创建，请参照 2.1 节先创建版本库。

### 创建测试文件，添加到版本库

本节需要删除文件，先创建一个测试文件 testdel.txt 添加到版本库，方便接下来场景的测试使用。

- 在 d:\git-demo 目录下创建文件 testdel.txt 

    内容如下：
    
    ```
    this file will be deleted.
    ```

- 添加到暂存区 

    ```
    $ git add testdel.txt
    ```

- 提交到版本库

    ```
    $ git commit -m "add a testdel file"
    ```

- 使用 git status 查看状态

    ```
    $ git status
    ```

### 场景一：在工作区删除一个文件，误操作，想要还原

- 将 testdel.txt 文件删除后发现是误操作，需要找回。

- 先使用 git status 查看下当前状态：

    ![删除文件1](https://static.oschina.net/uploads/img/201707/05145110_SXcp.png "删除文件1")
    
    可以看到我们删除了文件，也被当做是一次修改，再次证实暂存区管理的是修改而不是文件。

- 幸运的是之前将这个文件添加到版本库中，所以我们可以从版本库中取到该文件的备份。

- 使用 git checkout 指令从版本库的备份中取出文件
    
    ```
    $ git checkout -- testdel.txt
    ```
- 再次检查下 git-demo 目录，发现刚才删除的文件被找了回来。

### 场景二：在工作区删除一个文件，想要将版本库中该文件也删除

- 现在很明确要将 testdel.txt 文件删除；

- 分析需要删除两次，一次是删除工作区的该文件，一次是将版本库中最新备份中该文件删除；

- 删除本地工作区的 testdel.txt 文件：到 git-demo 目录下直接删除即可；

- 删除版本库中最新备份中的该文件，分两步走：

    - 前面说到删除本地文件也是一个修改，将这个修改告诉暂存区；
    
        ```
        // $ git rm <filename>
        $ git rm testdel.txt
        ```
    
    - 将暂存区的修改提交给分支仓库
    
        ```
        $ git commit -m "remove testdel.txt"
        ```

- 到这里为止分支仓库中最新备份中的 testdel.txt 也就被删除了。

### 场景三：在工作区删除一个文件，版本库中也删除了该文件，后来发现又需要想要还原

- 事情总不像想象中那么简单，已经在版本库的最新版本备份中将 testdel.txt 文件删除了，想想又后悔了；

- git 提供了极大的机动性，可以通过回到更久远之前的版本备份即可。

    详细内容在 2.3 节已经讲解过，这里简要略过。

# 分支

> 前面的章节不止一次的提到过分支仓库分支仓库，这一章就是说一说分支那些事儿。

## 分支简介

### 分支与版本库的关系

前面的章节中我们习惯于将分支仓库的概念等同于版本库，其实二者完全不同的两种概念。

在 2.2 中介绍了如何创建一个版本库，当一个版本库被创建成功时，它会默认的为我们创建一个 master 分支仓库，如下图所示：

![版本库设计原理图](https://static.oschina.net/uploads/img/201707/04232417_VJG2.png "版本库设计原理图")

我们姑且只看右边：

- 一个版本库中可以包含很多个分支仓库

    前面由于只有一个 master 分支仓库，所以我们好像把 master 的分支仓库就看成了版本库，其实它是版本库的一部分。

    ![版本库与分支的关系](https://static.oschina.net/uploads/img/201707/05160119_2mMC.png "版本库与分支的关系")

- 一个分支仓库中存放着不同时间的版本备份文件

    每次提交，Git 都把它们串成一条时间线，这条时间线就是一个分支。

    ![分支仓库是干嘛的](https://static.oschina.net/uploads/img/201707/05160258_F1FS.png "分支仓库是干嘛的")

> **我们不禁会想，自然一个分支仓库就可以记录不同时间的版本备份信息，为什么还需要整多个分支呢？**

### 为什么需要多个分支

![分支提高效率](https://static.oschina.net/uploads/img/201707/05162445_Ql94.png "分支提高效率")

> 分支的出现大大提高的团队开发的效率。

- 接到一个项目时，第一步是将项目的功能点进行拆分，然后分下去让开发人员进行开发对应的小模块；

- 第二步是将项目在版本库中的主分支进行备份。
 
    为什么强调主分支，原因是当我们突发灵感想要创作的时候可以创建一个自己的分支在上面进行试验，如果最终失败直接舍弃该分支即可，如果成功，将该分支往主分支上进行合并即可。

    主分支某种层面上将算是公共的东西。如果不使用其它分支，小明和小红都在主分支上进行开发，小明在第一天只开发了功能的百分之五十，然后将代码同步到主分支进行一次备份，而小红这时从主分支拉下了所有代码，由于小明的功能模块没有开发完成，导致小红这边启动项目时报错。
    
    可能又会说，那小明不能等全部开发完成再将代码上传到主分支吗？那么问题来了，小明第二天来继续昨天的开发，当开发到百分之七十的时候发现自己逻辑错误，想要回到昨天晚上的代码，由于代码没有全部开发完不能上传到主分支进行备份，所以只能手动凭借记忆一点点的复原。
    
- 第三步小明和小红分别从主分支上创建自己的分支。
        
    - 创建的自己分支与主分支在创建的那个时间点是一毛一样的；

    - 小明可以在每天工作结束时在自己的分支进行代码备份，以防第二天要还原之前某个版本，这个操作对主分支没有任何影响；
    
    - 小明等到自己的功能点全部开发完成时，将自己的分支与主分支进行合并，这时候小红下载主分支的代码就不会有任何问题了；
    
    - 在合并完自己的分支后就可以将自己的分支删除保持 Git 的简洁性。

## 操作分支

> 上一节介绍了分支的概念以及为什么需要使用分支，本节介绍分支具体是怎么操作的。

### 从主分支上创建 dev 分支

```
$ git branch dev        // 创建分支 dev
```

### 查看版本库中有哪些分支

当前分支前面会标一个 * 号。

```
$ git branch
   dev
 * master
```

### 切换到 dev 分支

```
$ git checkout dev
```

也可以使用更简单的方法一步创建并切换分支

```
$ git checkout -b dev   // 创建并切换分支
```

相当于下面两行代码：

```
$ git branch dev        // 创建分支 dev
$ git checkout dev      // 切换分支
```

### 在 dev 分支上修改文件后合并到主分支

- 测试 dev 分支上修改的文件在合并前对主分支是否有影响

    - 修改 readme.txt 文件，内容如下：
    
        ```
        create a readme.txt file.
        This is the second revision of the document.
        today is a sunny day.
        
        this is dev branch.     // 新增加的一句话
        ```
    - 添加并提交到 dev 分支仓库

        ```
        $ git add readme.txt 
        $ git commit -m "update readme.txt"
        ```

    - 切换到主分支查看 readme.txt 
    
        可以看到没有刚才新增的那句话。

        ```
        $ git branch master
        ```
- 将 dev 分支合并到 master 主分支
    
    - 切换到 master 分支
    
        ```
        $ git checkout master
        ```
        
    - 使用 git merge 指令合并
        
        将 dev 分支合并到当前分支（master）上。
    
        ```
        $ git merge dev
        ```
        
    - 再次查看 readme.txt
    
        可以看到刚才在 dev 分支上对 readme.txt 文件的修改也一并合并过来了。
        
### 删除 dev 分支

将 dev 分支合并到 master 分支上之后， dev 分支也就没有用了，可以进行删除。

- 切换到 master 分支

    ```
    $ git branch master
    ```

- 删除 dev 分支
 
    ```
    $ git branch -d dev
    ```

- 查看版本库中分支

    dev 分支已被删除，只剩 master 分支了。

    ```
    $ git branch 
     * master
    ```

### 总结

- 新建分支  
    
    ```
    $ git branch <branchname>
    ```

- 查看分支

    ```
    $ git branch
    ```
    
- 切换分支

    ```
    $ git checkout <branchname>
    ```

- 合并分支

    ```
    $ git merge <branchname>
    ```

- 删除分支

    ```
    $ git branch -d <branchname>
    ```
    
- 创建并切换分支

    ```
    $ git checkout -b <branchname>
    ```

# 标签

## 标签简介

- 我们知道，每一次 commit 操作都会往当前分支提交一个版本备份，这个版本备份包含以下内容：

    - commit：每创建一条版本备份时，都会用 SHA1 生成一个很大的数字，并用十六进制进行表示，目的是根据这个 commit id 可以找到对应的版本信息，不会重复。
    
    - Author：提交这条版本信息的人是谁，适用于团队开发时，记录每个版本是谁提交的，这样出了问题也好找对应的负责人解决问题。
    
    - Date：这个就是提交到分支仓库的时间了。
    
    - 再下面用红框框起来的东东叫做版本描述信息，如果没有它，你看到的只是一大串数字，压根不知道这条版本到底做了哪些修改。

- 如果我们想要找某个版本，可以说“**那个谁，把 master 分支上 commit id 为 6a5819e 的那个版本打下包**”。

    - commit id 一般冗长而又没有规律可寻，用 commit id 去快速找某个版本不是明智之举。

- 标签就是解决上面那种尴尬的情况。

    - 一个标签与一个 commit id 号一一对应，比如我们给 commit id 为 6a5819e 的那个版本备份打上个标签叫做 v1.0，之后只需说“**把 master 分支上 v1.0 那个版本打个包**”。
    
    - 二者一对比好处自然不言而喻。

## 操作标签

> 上一节介绍了什么是标签以及为什么要使用标签，这一节具体介绍下标签是怎么操作的。

### 给当前分支版本备份打标签

- 切换到 master 分支

    ```
    $ git checkout master
    ```

- 查看分支仓库中版本备份日志
    
    ![最近的版本备份信息](https://static.oschina.net/uploads/img/201707/05180718_KfAr.png "最近的版本备份信息")

- 使用 git tag 指令为任意版本备份打标签

    ```
    // $ git tag <tagname> <commit id>
    $ git tag v1.0 12964b
    ```

    注：commit id 不需要全部写上，截取前面 6-7 位即可。

- 如果不加上 <commit id>，也是可以的，默认给最近的版本信息打标签

    ```
    $ git tag v1.0
    ```
    
    上述没有加上 <commit id>，在本例中就是给最近的版本信息 "update readme.txt" 打标签。
    
- 有时我们打的标签可能不能很好的表明意思，可以像 git commit 一样使用 -m 参数来记录描述信息

    ```
    $ git tag -a v1.0 -m "update readme.txt" 12964b
    ```

    这里使用 -a 参数来指定标签名。

### 查看当前分支有哪些标签

上面新增了几个标签，我们想查看下当前分支下有哪些标签，可以使用指令 git tag：

```
$ git tag
v0.9
v1.0
```

### 标签打错了，可以删除标签重新打

上面的 v1.0 版本打错了，应该打成 v1.0 标签的同时带上描述信息。

- 删除 v1.0 标签

    ```
    // $ git tag -d <tagname>
    $ git tag -d v1.0
    ```

- 重新打上 v1.0 标签，同时使用 -m 参数带上描述信息

    ```
    $ git tag -a v1.0 -m "update readme.txt" 12964b
    ```